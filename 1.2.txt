1.	Чтобы посмотреть изменения в рабочем дереве которые еще не помещены в кэш
	Предположение: Сравшения изменений файлов относительно индекса,
	файлы которые не попадут вместе комитом, еще не добавленны
	git diff

	Изменения между индексом и последним коммитом, они попадут в месте с коммитом
	git diff --staged
	git diff --cached

	Чтобы сравнить рабочее дерево с последним коммитом 
	git diff HEAD
	git status
	Тренировка: Создаем папку 2.1, создаем хранилище, 
	1.добавляем два файла, сравниваем,
	2.добавляем 1 в индекс, сравниваем, сравниваем --staged --cached
	3.Сравниваем рабочее дерево с последним коммитом


GIT RESET!!!!!
Для того чтобы помещеные файлы индекс,  исключить его от туда обрано
	Суть: Перемещает указатель текущей ветки в другую позицию и 
	     дополнительно может обновить сцену и рабочее дерево

	Если указан только коммит без имен файлов то указатель ветки переведется на этот коммит, а затем
	сцена перевется в соответствии с этим коммитом. ключ --soft сцена не будет изменена -hard то будет обновлена и счена и рабочее дерево git reset HEAD~3
	git reset - если имя коммита не будет указанна тогда по умолчанию берется HEAD, указатель ветки не будет перемещен, 
	сцена будет переведена в это состояние если --hard то и рабочее дерево тоже
	Если указанные имя файла (и/или ключ -p) тогда работает аналогично checkout с именем файла только будет изменена сцена, рабочий каталог изменен не будет пример использования git reset -- <files>  если вместо "--" поместить имя коммита то файл возмется из него иначе с HEAD
	Тренировка: Перевести указатель ветки на несколько шагов, сравнить рабочее дерево с новым положением временой точки на ветке
		     

git reset HEAD Имя файла
git status


GIT CHECKOUT!!!!
Проверить это должно перезаписать файл который не в кеше
git checkout -- ИмяФайла
visual git guide

	Суть: Для копирования в рабочее дерево из истории или сцены
	      Движения по временной школе не происходит.
		Тренировка:Достать файл из текущего коммита на сцену, в рабочее дерево, 
		только на сцену, тоже саммое только из предыдущих коммитов
		
	      Переключение между ветками, создание новой ветки
		Тренировка: Переключиться между ветками, зафиксировать правила изменения рабочего дерева(в каких случаях не изменинятся файлы а в каких удаляться, добавятся

		Если не указывается не имя файла не имя ветки а -
		-тэг
		-дистанционную ветку
		-или что-то вроде master~3 ТО ПОЛУЧАЕМ "Detached HEAD" 
		git checkout v.1.1.3 скомпилить удалить и вернуться обратно git checkout master
		Особенность копитов с "отверченной головой" необходимо создавать ветки а то все пропадет
		Тренировка переместиться вниз по истории (отвертить голову) добавить коммит проверить что данные потерялись 
		Отвертить головоу вниз по истории добавить ветвь закомитить и потом сравнить сохранились ли эти комиты 


		
	      	 



git commit -a -m "asdfasdf"

git reset --soft HEAD^

git add ИмяФайла
git commit --amend -m "что-то там сделал"

git reset --soft HEAD^ Undo last commit, put changes into staging
	Замещает последний коммит текущим индексом
	git commit --amend -m "New message"
	
git reset --hard HEAD^ Undo last commit and all changes
git reset --hard HEAD^ Undo last 2 commit and all changes

git remote
Hosted - GitHub, BitBucket
Self Managed - Gitosis, Gitorious

git remote add origin https://github.com/Gregg/git-real.git
git remote -v

git push -u origin master Закидываем ветку мастер в удаленый репозиторий

git pull -получаем обновления из репозитория обратно

git remote add <name> <adress>
git remote rm <name>
git push -u <name> <branch>

HEROKU
heroku create
git remote -v
git push heroku master

